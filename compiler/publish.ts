import chalk from "chalk";
import { compile, type CompileResult } from "./compile";
import {
  publishToGitHub,
  type PublishMode,
  type PublishSummary,
} from "../adapters/github/publish";

// -------------------------------------------------------------------------
// Argument parsing
// -------------------------------------------------------------------------

const modeFromArgs = (): PublishMode => {
  if (process.argv.includes("--pr")) {
    return "pr";
  }
  if (process.argv.includes("--commit")) {
    return "commit-only";
  }
  if (process.argv.includes("--dry")) {
    return "dry-run";
  }
  const arg = process.argv.find((item) => item.startsWith("--mode="));
  if (!arg) {
    return "dry-run";
  }
  const value = arg.split("=")[1];
  if (value === "commit-only" || value === "dry-run" || value === "pr") {
    return value;
  }
  return "dry-run";
};

// -------------------------------------------------------------------------
// Colourised output helpers
// -------------------------------------------------------------------------

const formatSummaryTable = (summary: {
  created: number;
  modified: number;
  deleted: number;
}): string => {
  const lines = [
    chalk.bold("Summary"),
    chalk.dim("-------"),
    `${chalk.green("created:")}  ${summary.created}`,
    `${chalk.yellow("modified:")} ${summary.modified}`,
    `${chalk.red("deleted:")}  ${summary.deleted}`,
  ];
  return lines.join("\n");
};

/**
 * Colour a unified diff string line-by-line.
 */
const colouriseDiff = (diff: string): string => {
  return diff
    .split("\n")
    .map((line) => {
      if (line.startsWith("diff ")) return chalk.bold(line);
      if (line.startsWith("---") || line.startsWith("+++"))
        return chalk.bold.dim(line);
      if (line.startsWith("@@")) return chalk.cyan(line);
      if (line.startsWith("+")) return chalk.green(line);
      if (line.startsWith("-")) return chalk.red(line);
      return chalk.dim(line);
    })
    .join("\n");
};

/**
 * Guess a per-file status symbol from the diff text.
 * Looks for "new file mode" / "deleted file mode" markers.
 */
const fileStatusFromDiff = (
  filePath: string,
  diff: string
): { symbol: string; color: (s: string) => string } => {
  // Simple heuristic: search for the file in the diff and check markers
  const escaped = filePath.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const pattern = new RegExp(`diff --git a/${escaped}.*\\n(.*?)\\n`, "s");
  const match = diff.match(pattern);
  if (match) {
    const nextLine = match[1] ?? "";
    if (nextLine.includes("new file")) return { symbol: "+", color: chalk.green };
    if (nextLine.includes("deleted file")) return { symbol: "-", color: chalk.red };
  }
  return { symbol: "~", color: chalk.yellow };
};

// -------------------------------------------------------------------------
// PR body (plain text -- not colourised, this goes to GitHub)
// -------------------------------------------------------------------------

const buildPrBody = (
  timestamp: string,
  summary: PublishSummary
): string => {
  const lines = [
    `Generated by Studio compiler at ${timestamp}`,
    "",
    "## Summary",
    `- created: ${summary.created}`,
    `- modified: ${summary.modified}`,
    `- deleted: ${summary.deleted}`,
  ];

  if (summary.paths.length > 0) {
    lines.push("", "## Changed files");
    summary.paths.forEach((filePath) => lines.push(`- \`${filePath}\``));
  }

  return lines.join("\n");
};

// -------------------------------------------------------------------------
// Main
// -------------------------------------------------------------------------

export async function publish(): Promise<void> {
  const compileResult = await compile({ write: false });
  const files = compileResult.files;
  const mode = modeFromArgs();

  // Use a stable branch name so duplicate PR detection works. If a PR
  // already exists for this branch, the adapter will report it instead of
  // creating a second one.
  const headBranch = "studio/pending";

  // For PR mode we need the summary first to build the body, but the
  // adapter needs the body at call time. We solve this by doing a two-pass
  // approach: first run a dry-run to get the summary, then run the real
  // mode with the body built from the summary.
  let body: string | undefined;
  if (mode === "pr") {
    const dryResult = await publishToGitHub({
      repoPath: process.cwd(),
      baseBranch: "main",
      headBranch,
      title: "chore(studio): UI update",
      mode: "dry-run",
      files,
    });
    body = buildPrBody(new Date().toISOString(), dryResult);
  }

  const result = await publishToGitHub({
    repoPath: process.cwd(),
    baseBranch: "main",
    headBranch,
    title: "chore(studio): UI update",
    body,
    mode,
    files,
  });

  // -- Colourised terminal output --

  console.log(formatSummaryTable(result));

  if (result.paths.length > 0) {
    console.log(chalk.bold("\nChanged files:"));
    for (const filePath of result.paths) {
      const { symbol, color } = fileStatusFromDiff(filePath, result.diff);
      console.log(color(`  ${symbol} ${filePath}`));
    }
  }

  if (mode === "dry-run" && result.diff.length > 0) {
    console.log(chalk.bold("\nDiff:\n"));
    console.log(colouriseDiff(result.diff));
  }

  if (result.prUrl) {
    console.log(`\nPR: ${chalk.cyan.underline(result.prUrl)}`);
  }
}

if (require.main === module) {
  publish().catch((error) => {
    console.error(error);
    process.exit(1);
  });
}
