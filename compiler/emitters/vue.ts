/**
 * Vue SFC emitter -- generates .vue Single File Components from screen specs.
 */

import type { Node, ScreenSpec } from "../types";
import type { StudioConfig } from "../config";
import type { Emitter, EmittedFile, EmitScreenResult } from "./types";

// ---------------------------------------------------------------------------
// Token maps (same values as Next.js emitter)
// ---------------------------------------------------------------------------

const GAP_MAP: Record<string, string> = {
  xs: "0.25rem",
  sm: "0.5rem",
  md: "1rem",
  lg: "1.5rem",
  xl: "2rem",
};

const SIZE_MAP: Record<string, string> = {
  xs: "0.5rem",
  sm: "1rem",
  md: "1.5rem",
  lg: "2rem",
  xl: "3rem",
};

const resolveGap = (gap?: unknown): string => {
  if (typeof gap !== "string") return GAP_MAP.md;
  return GAP_MAP[gap] ?? GAP_MAP.md;
};

const resolveSize = (size?: unknown): string => {
  if (typeof size !== "string") return SIZE_MAP.md;
  return SIZE_MAP[size] ?? SIZE_MAP.md;
};

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

const HEADER =
  "<!-- AUTO-GENERATED by studio compiler. Do not edit directly. -->\n\n";

const escapeText = (value: unknown): string => {
  const str = typeof value === "string" ? value : String(value ?? "");
  return str
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
};

function componentNameFromRoute(route: string): string {
  if (route === "/") return "Home";
  const segments = route
    .split("/")
    .filter(Boolean)
    .map((s) => s.charAt(0).toUpperCase() + s.slice(1));
  return segments.join("");
}

function toKebabCase(name: string): string {
  return name
    .replace(/([a-z])([A-Z])/g, "$1-$2")
    .replace(/([A-Z])([A-Z][a-z])/g, "$1-$2")
    .toLowerCase();
}

// ---------------------------------------------------------------------------
// Node emission -- produces HTML template strings
// ---------------------------------------------------------------------------

function emitNode(node: Node, indent: number = 2): string {
  const props = node.props ?? {};
  const type = node.type;
  const pad = " ".repeat(indent);

  switch (type) {
    case "Stack": {
      const gap = resolveGap(props.gap);
      const padding = props.padding ? `; padding: ${resolveSize(props.padding)}` : "";
      const direction = props.direction === "row" ? "row" : "column";
      const children = emitChildren(node.children ?? [], indent + 2);
      return `${pad}<div style="display: flex; flex-direction: ${direction}; gap: ${gap}${padding}">\n${children}\n${pad}</div>`;
    }

    case "Grid": {
      const columns = typeof props.columns === "number" ? props.columns : 2;
      const gap = resolveGap(props.gap);
      const children = emitChildren(node.children ?? [], indent + 2);
      return `${pad}<div style="display: grid; grid-template-columns: repeat(${columns}, 1fr); gap: ${gap}">\n${children}\n${pad}</div>`;
    }

    case "Section": {
      const padding = props.padding ? ` style="padding: ${resolveSize(props.padding)}"` : "";
      const children = emitChildren(node.children ?? [], indent + 2);
      return `${pad}<section${padding}>\n${children}\n${pad}</section>`;
    }

    case "ScrollArea": {
      const height = typeof props.height === "string" ? props.height : "auto";
      const children = emitChildren(node.children ?? [], indent + 2);
      return `${pad}<div style="overflow: auto; height: ${height}">\n${children}\n${pad}</div>`;
    }

    case "Spacer": {
      const size = resolveSize(props.size);
      return `${pad}<div style="height: ${size}"></div>`;
    }

    case "Heading": {
      const text = escapeText(props.text);
      const level = typeof props.level === "number" ? props.level : 1;
      const tag = `h${Math.min(Math.max(level, 1), 6)}`;
      return `${pad}<${tag}>${text}</${tag}>`;
    }

    case "Text": {
      const text = escapeText(props.text);
      if (props.variant === "muted") {
        return `${pad}<p class="text-muted">${text}</p>`;
      }
      return `${pad}<p>${text}</p>`;
    }

    case "Image": {
      const src = escapeText(props.src);
      const alt = escapeText(props.alt);
      const attrs: string[] = [`src="${src}"`, `alt="${alt}"`];
      if (typeof props.width === "number") attrs.push(`:width="${props.width}"`);
      if (typeof props.height === "number") attrs.push(`:height="${props.height}"`);
      return `${pad}<img ${attrs.join(" ")} />`;
    }

    case "Input": {
      const attrs: string[] = [];
      if (typeof props.type === "string") attrs.push(`type="${props.type}"`);
      if (typeof props.placeholder === "string")
        attrs.push(`placeholder="${escapeText(props.placeholder)}"`);
      const attrStr = attrs.length > 0 ? " " + attrs.join(" ") : "";
      if (typeof props.label === "string" && props.label) {
        return `${pad}<div>\n${pad}  <label>${escapeText(props.label)}</label>\n${pad}  <input${attrStr} />\n${pad}</div>`;
      }
      return `${pad}<input${attrStr} />`;
    }

    case "Link": {
      const href = typeof props.href === "string" ? props.href : "#";
      const text = typeof props.text === "string" ? escapeText(props.text) : href;
      return `${pad}<router-link to="${href}">${text}</router-link>`;
    }

    case "Divider": {
      return `${pad}<hr />`;
    }

    case "List": {
      const items = Array.isArray(props.items) ? props.items : [];
      const ordered = props.ordered === true;
      const tag = ordered ? "ol" : "ul";
      const lis = items
        .map((item) => `${pad}  <li>${escapeText(item)}</li>`)
        .join("\n");
      return `${pad}<${tag}>\n${lis}\n${pad}</${tag}>`;
    }

    case "Card": {
      const padding = props.padding ? resolveSize(props.padding) : "1rem";
      const children = emitChildren(node.children ?? [], indent + 2);
      return `${pad}<div class="card" style="padding: ${padding}; border: 1px solid var(--border); border-radius: 0.5rem">\n${children}\n${pad}</div>`;
    }

    case "Button": {
      const label = escapeText(props.label ?? "Button");
      const attrs: string[] = [];
      if (typeof props.intent === "string" && props.intent !== "primary") {
        attrs.push(`class="btn-${props.intent}"`);
      }
      const attrStr = attrs.length > 0 ? " " + attrs.join(" ") : "";
      return `${pad}<button${attrStr}>${label}</button>`;
    }

    case "Form": {
      const formAttrs: string[] = [];
      if (typeof props.action === "string") formAttrs.push(`action="${escapeText(props.action)}"`);
      if (typeof props.method === "string") formAttrs.push(`method="${props.method}"`);
      const attrStr = formAttrs.length > 0 ? " " + formAttrs.join(" ") : "";
      const children = emitChildren(node.children ?? [], indent + 2);
      return `${pad}<form${attrStr}>\n${children}\n${pad}</form>`;
    }

    case "Modal": {
      const title = escapeText(props.title ?? "Dialog");
      const children = emitChildren(node.children ?? [], indent + 4);
      return `${pad}<dialog open style="position:fixed;inset:0;z-index:50">\n${pad}  <div style="max-width:28rem;margin:auto;background:white;border-radius:0.75rem;box-shadow:0 25px 50px -12px rgb(0 0 0 / 0.25)">\n${pad}    <div style="padding:0.75rem 1rem;border-bottom:1px solid var(--border)"><strong>${title}</strong></div>\n${pad}    <div style="padding:1rem">\n${children}\n${pad}    </div>\n${pad}  </div>\n${pad}</dialog>`;
    }

    case "Tabs": {
      const tabs = Array.isArray(props.tabs) ? props.tabs.map(String) : ["Tab 1", "Tab 2"];
      const tabButtons = tabs.map((tab, i) =>
        `${pad}    <button :class="{ active: ${i === 0} }">${escapeText(tab)}</button>`
      ).join("\n");
      const children = emitChildren(node.children ?? [], indent + 2);
      return `${pad}<div>\n${pad}  <div style="display:flex;border-bottom:1px solid var(--border);margin-bottom:0.75rem">\n${tabButtons}\n${pad}  </div>\n${pad}  <div>\n${children}\n${pad}  </div>\n${pad}</div>`;
    }

    case "Nav": {
      const orientation = props.orientation === "vertical" ? "column" : "row";
      const items = Array.isArray(props.items) ? props.items : [];
      const navItems = items.map((item) => {
        const str = String(item);
        const [label, href] = str.includes("|") ? str.split("|") : [str, "#"];
        return `${pad}  <router-link to="${href}">${escapeText(label)}</router-link>`;
      }).join("\n");
      const children = emitChildren(node.children ?? [], indent + 2);
      return `${pad}<nav style="display:flex;flex-direction:${orientation};gap:0.25rem">\n${navItems}\n${children}\n${pad}</nav>`;
    }

    case "DataTable": {
      const columns = Array.isArray(props.columns) ? props.columns : [];
      const rows = Array.isArray(props.rows) ? props.rows : [];
      const parsedCols = columns.map((c) => {
        const str = String(c);
        if (str.includes("|")) { const [key, label] = str.split("|"); return { key, label }; }
        return { key: str, label: str };
      });
      const parsedRows = rows.map((r) => {
        if (typeof r === "object" && r !== null) return r as Record<string, unknown>;
        try { return JSON.parse(String(r)) as Record<string, unknown>; } catch { return {} as Record<string, unknown>; }
      });
      const ths = parsedCols.map((col) => `${pad}        <th>${escapeText(col.label)}</th>`).join("\n");
      const trs = parsedRows.map((row) => {
        const tds = parsedCols.map((col) => `${pad}          <td>${escapeText(String(row[col.key] ?? ""))}</td>`).join("\n");
        return `${pad}        <tr>\n${tds}\n${pad}        </tr>`;
      }).join("\n");
      return `${pad}<table>\n${pad}    <thead>\n${pad}      <tr>\n${ths}\n${pad}      </tr>\n${pad}    </thead>\n${pad}    <tbody>\n${trs}\n${pad}    </tbody>\n${pad}</table>`;
    }

    // Repo component
    default: {
      const kebab = toKebabCase(type);
      const propEntries = Object.entries(props);
      const attrStr = propEntries
        .map(([key, value]) => {
          if (typeof value === "string") return `${key}="${escapeText(value)}"`;
          return `:${key}="${JSON.stringify(value)}"`;
        })
        .join(" ");
      const attrs = attrStr ? ` ${attrStr}` : "";

      if (node.children && node.children.length > 0) {
        const children = emitChildren(node.children, indent + 2);
        return `${pad}<${kebab}${attrs}>\n${children}\n${pad}</${kebab}>`;
      }
      return `${pad}<${kebab}${attrs} />`;
    }
  }
}

function emitChildren(nodes: Node[], indent: number): string {
  return nodes.map((node) => emitNode(node, indent)).join("\n");
}

// ---------------------------------------------------------------------------
// Screen-level emission
// ---------------------------------------------------------------------------

function emitScreen(
  spec: ScreenSpec,
  config: StudioConfig
): EmitScreenResult {
  const componentName = componentNameFromRoute(spec.route);
  const generatedPath = `${config.generatedDir}/${componentName}.generated.vue`;

  const template = emitNode(spec.tree, 4);

  const contents = `${HEADER}<template>
  <div>
${template}
  </div>
</template>

<script setup lang="ts">
// ${componentName} -- auto-generated component
</script>
`;

  return {
    files: [{ path: generatedPath, contents }],
    componentName,
  };
}

function emitBarrelIndex(
  componentNames: string[],
  config: StudioConfig
): EmittedFile {
  const exports = componentNames
    .sort()
    .map((name) => `export { default as ${name} } from "./${name}.generated.vue";`)
    .join("\n");

  return {
    path: `${config.generatedDir}/index.ts`,
    contents: `// AUTO-GENERATED by studio compiler. Do not edit directly.\n\n${exports}\n`,
  };
}

// ---------------------------------------------------------------------------
// Emitter interface implementation
// ---------------------------------------------------------------------------

export const vueEmitter: Emitter = {
  name: "vue",
  emitScreen,
  emitBarrelIndex,
};
