import type { Node, NodeInteractions, DataSource, ScreenSpec } from "../types";
import type { StudioConfig } from "../config";
import type { Emitter, EmittedFile, EmitScreenResult } from "./types";

type EmitResult = {
  jsx: string;
  imports: Set<string>;
};

// ---------------------------------------------------------------------------
// Token maps
// ---------------------------------------------------------------------------

const GAP_MAP: Record<string, string> = {
  xs: "1",
  sm: "2",
  md: "4",
  lg: "6",
  xl: "8",
};

const SIZE_MAP: Record<string, string> = {
  xs: "2",
  sm: "4",
  md: "6",
  lg: "8",
  xl: "12",
};

const resolveGap = (gap?: unknown): string => {
  if (typeof gap !== "string") return GAP_MAP.md;
  return GAP_MAP[gap] ?? GAP_MAP.md;
};

const resolveSize = (size?: unknown): string => {
  if (typeof size !== "string") return SIZE_MAP.md;
  return SIZE_MAP[size] ?? SIZE_MAP.md;
};

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

const HEADER =
  "/** AUTO-GENERATED by studio compiler. Do not edit directly. */\n\n";

const escapeText = (value: unknown): string => {
  const str = typeof value === "string" ? value : String(value ?? "");
  return str
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
};

const indentLines = (value: string, spaces: number): string => {
  const pad = " ".repeat(spaces);
  return value
    .split("\n")
    .map((line) => (line.length > 0 ? `${pad}${line}` : line))
    .join("\n");
};

const mergeImports = (target: Set<string>, source: Set<string>): void => {
  source.forEach((item) => target.add(item));
};

/**
 * Derive a PascalCase component name from a route.
 *   "/" -> "Home"
 *   "/signup" -> "Signup"
 *   "/settings/profile" -> "SettingsProfile"
 */
function componentNameFromRoute(route: string): string {
  if (route === "/") return "Home";
  const segments = route
    .split("/")
    .filter(Boolean)
    .flatMap((s) => s.split("-"))
    .map((s) => s.charAt(0).toUpperCase() + s.slice(1));
  return segments.join("");
}

/**
 * Derive the page output path from a route.
 *   "/" -> "{appDir}/page.tsx"
 *   "/signup" -> "{appDir}/signup/page.tsx"
 */
function pagePathFromRoute(route: string, appDir: string): string {
  if (route === "/") return `${appDir}/page.tsx`;
  const segments = route.split("/").filter(Boolean).join("/");
  return `${appDir}/${segments}/page.tsx`;
}

// ---------------------------------------------------------------------------
// Import resolution
// ---------------------------------------------------------------------------

type ImportEntry = {
  specifier: string;
  source: string;
  isDefault?: boolean;
};

const IMPORT_MAP: Record<string, ImportEntry> = {
  Button: { specifier: "Button", source: "@/components/ui/button" },
  Card: { specifier: "Card", source: "@/components/ui/card" },
  Input: { specifier: "Input", source: "@/components/ui/input" },
  ScrollArea: {
    specifier: "ScrollArea",
    source: "@/components/ui/scroll-area",
  },
  Separator: { specifier: "Separator", source: "@/components/ui/separator" },
  Link: { specifier: "Link", source: "next/link", isDefault: true },
};

/**
 * Convert PascalCase to kebab-case for file paths.
 * e.g. "UserProfile" -> "user-profile"
 */
function toKebabCase(name: string): string {
  return name
    .replace(/([a-z])([A-Z])/g, "$1-$2")
    .replace(/([A-Z])([A-Z][a-z])/g, "$1-$2")
    .toLowerCase();
}

function buildImportLines(imports: Set<string>, config: StudioConfig): string {
  const defaultImports: { specifier: string; source: string }[] = [];
  // Group named imports by source
  const bySource = new Map<string, string[]>();

  for (const key of Array.from(imports).sort()) {
    // Lucide icon imports: "lucide:IconName"
    if (key.startsWith("lucide:")) {
      const iconName = key.slice(7);
      const existing = bySource.get("lucide-react") ?? [];
      if (!existing.includes(iconName)) {
        existing.push(iconName);
      }
      bySource.set("lucide-react", existing);
      continue;
    }

    const entry = IMPORT_MAP[key];
    if (entry) {
      if (entry.isDefault) {
        defaultImports.push({ specifier: entry.specifier, source: entry.source });
      } else {
        const existing = bySource.get(entry.source) ?? [];
        existing.push(entry.specifier);
        bySource.set(entry.source, existing);
      }
      continue;
    }

    // Repo component: import from componentsDir using kebab-case convention
    const kebab = toKebabCase(key);
    const source = `${config.importAlias}components/ui/${kebab}`;
    const existing = bySource.get(source) ?? [];
    existing.push(key);
    bySource.set(source, existing);
  }

  const lines: string[] = [];
  // Default imports first
  for (const { specifier, source } of defaultImports.sort((a, b) =>
    a.source.localeCompare(b.source)
  )) {
    lines.push(`import ${specifier} from "${source}";`);
  }
  // Named imports
  const sortedSources = Array.from(bySource.keys()).sort();
  for (const source of sortedSources) {
    const specifiers = bySource.get(source)!;
    lines.push(`import { ${specifiers.join(", ")} } from "${source}";`);
  }
  return lines.length > 0 ? lines.join("\n") + "\n\n" : "";
}

// ---------------------------------------------------------------------------
// Interaction & data binding helpers
// ---------------------------------------------------------------------------

/** Collect all state variable names needed by interactions in a tree. */
function collectInteractionState(node: Node): Set<string> {
  const states = new Set<string>();
  if (node.interactions) {
    if (node.interactions.onClick?.action === "toggleVisibility" && node.interactions.onClick.target) {
      states.add(node.interactions.onClick.target);
    }
    if (node.interactions.onChange?.action === "setState" && node.interactions.onChange.target) {
      states.add(node.interactions.onChange.target);
    }
    if (node.interactions.visibleWhen?.state) {
      states.add(node.interactions.visibleWhen.state);
    }
  }
  for (const child of node.children ?? []) {
    collectInteractionState(child).forEach((s) => states.add(s));
  }
  return states;
}

/** Collect all data source configs from List/DataTable nodes for useEffect generation. */
function collectApiSources(node: Node): Array<{ nodeId: string; url: string }> {
  const sources: Array<{ nodeId: string; url: string }> = [];
  if (node.dataSource?.type === "api" && node.dataSource.url) {
    sources.push({ nodeId: node.id, url: node.dataSource.url });
  }
  for (const child of node.children ?? []) {
    sources.push(...collectApiSources(child));
  }
  return sources;
}

/** Build onClick handler string for an interaction. */
function buildOnClick(interactions: NodeInteractions): string {
  if (!interactions.onClick) return "";
  const { action, target, code } = interactions.onClick;
  switch (action) {
    case "navigate":
      return target ? ` onClick={() => router.push("${target}")}` : "";
    case "toggleVisibility":
      return target ? ` onClick={() => set${capitalize(target)}((v) => !v)}` : "";
    case "custom":
      return code ? ` onClick={() => { ${code} }}` : "";
    default:
      return "";
  }
}

/** Build onChange handler string for an interaction. */
function buildOnChange(interactions: NodeInteractions): string {
  if (!interactions.onChange) return "";
  const { action, target, code } = interactions.onChange;
  switch (action) {
    case "setState":
      return target ? ` onChange={(e) => set${capitalize(target)}(e.target.value)}` : "";
    case "custom":
      return code ? ` onChange={(e) => { ${code} }}` : "";
    default:
      return "";
  }
}

function capitalize(s: string): string {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

/** Build data binding code for a node with dataSource. */
function emitDataSource(node: Node): { dataVarName: string; jsx: string } | null {
  const ds = node.dataSource;
  if (!ds) return null;
  const varName = `data_${node.id.replace(/[^a-zA-Z0-9]/g, "_")}`;
  if (ds.type === "static" || ds.type === "mock") {
    const dataArr = Array.isArray(ds.data) ? ds.data : [];
    return {
      dataVarName: varName,
      jsx: `const ${varName} = ${JSON.stringify(dataArr)};`,
    };
  }
  if (ds.type === "api" && ds.url) {
    return {
      dataVarName: varName,
      jsx: "", // handled at component level via useEffect
    };
  }
  return null;
}

// ---------------------------------------------------------------------------
// Node emission
// ---------------------------------------------------------------------------

function emitNode(node: Node): EmitResult {
  const props = node.props ?? {};
  const type = node.type;

  switch (type) {
    // -- Layout primitives --------------------------------------------------

    case "Stack": {
      const gap = resolveGap(props.gap);
      const padding = props.padding ? ` p-${resolveSize(props.padding)}` : "";
      const direction = props.direction === "row" ? "flex-row" : "flex-col";
      const children = emitChildren(node.children ?? []);
      const body = children.jsx
        ? `\n${indentLines(children.jsx, 2)}\n`
        : "";
      return {
        jsx: `<div className="${direction} flex gap-${gap}${padding}">${body}</div>`,
        imports: children.imports,
      };
    }

    case "Grid": {
      const columns = typeof props.columns === "number" ? props.columns : 2;
      const gap = resolveGap(props.gap);
      const children = emitChildren(node.children ?? []);
      const body = children.jsx
        ? `\n${indentLines(children.jsx, 2)}\n`
        : "";
      return {
        jsx: `<div className="grid grid-cols-${columns} gap-${gap}">${body}</div>`,
        imports: children.imports,
      };
    }

    case "Section": {
      const padding = props.padding ? ` p-${resolveSize(props.padding)}` : "";
      const children = emitChildren(node.children ?? []);
      const body = children.jsx
        ? `\n${indentLines(children.jsx, 2)}\n`
        : "";
      return {
        jsx: `<section className="w-full${padding}">${body}</section>`,
        imports: children.imports,
      };
    }

    case "ScrollArea": {
      const height = typeof props.height === "string" ? props.height : "auto";
      const children = emitChildren(node.children ?? []);
      const body = children.jsx
        ? `\n${indentLines(children.jsx, 2)}\n`
        : "";
      return {
        jsx: `<ScrollArea className="h-[${height}]">${body}</ScrollArea>`,
        imports: new Set(["ScrollArea", ...Array.from(children.imports)]),
      };
    }

    case "Spacer": {
      const size = resolveSize(props.size);
      return {
        jsx: `<div className="h-${size}" />`,
        imports: new Set(),
      };
    }

    // -- Content nodes ------------------------------------------------------

    case "Heading": {
      const text = escapeText(props.text);
      const level = typeof props.level === "number" ? props.level : 1;
      const tag = `h${Math.min(Math.max(level, 1), 6)}`;
      const fontFamily = typeof props.fontFamily === "string" && props.fontFamily ? props.fontFamily : "";
      const styleAttr = fontFamily ? ` style={{ fontFamily: "${fontFamily}" }}` : "";
      // Map variant or fall back to level-based sizing
      const HEADING_SIZE: Record<string, string> = {
        hero: "text-5xl font-bold tracking-tight",
        title: "text-3xl font-bold",
        subtitle: "text-xl font-medium",
        section: "text-lg font-semibold",
      };
      const HEADING_LEVEL_SIZE: Record<number, string> = {
        1: "text-3xl font-bold",
        2: "text-2xl font-semibold",
        3: "text-xl font-semibold",
        4: "text-lg font-semibold",
        5: "text-base font-medium",
        6: "text-sm font-medium",
      };
      const variant = typeof props.variant === "string" ? props.variant : "";
      const sizeClass = HEADING_SIZE[variant] ?? HEADING_LEVEL_SIZE[level] ?? "text-xl font-semibold";
      return {
        jsx: `<${tag} className="${sizeClass}"${styleAttr}>${text}</${tag}>`,
        imports: new Set(),
      };
    }

    case "Text": {
      const content = escapeText(props.text);
      const fontFamily = typeof props.fontFamily === "string" && props.fontFamily ? props.fontFamily : "";
      const styleAttr = fontFamily ? ` style={{ fontFamily: "${fontFamily}" }}` : "";
      if (props.variant === "body") {
        return {
          jsx: `<p className="text-base"${styleAttr}>${content}</p>`,
          imports: new Set(),
        };
      }
      if (props.variant === "muted") {
        return {
          jsx: `<p className="text-sm text-muted-foreground"${styleAttr}>${content}</p>`,
          imports: new Set(),
        };
      }
      return { jsx: `<p${styleAttr}>${content}</p>`, imports: new Set() };
    }

    case "Image": {
      const src = escapeText(props.src);
      const alt = escapeText(props.alt);
      const widthAttr =
        typeof props.width === "number" ? ` width={${props.width}}` : "";
      const heightAttr =
        typeof props.height === "number" ? ` height={${props.height}}` : "";
      return {
        jsx: `<img src="${src}" alt="${alt}"${widthAttr}${heightAttr} />`,
        imports: new Set(),
      };
    }

    case "Input": {
      const attrs: string[] = [];
      if (typeof props.type === "string") attrs.push(`type="${props.type}"`);
      if (typeof props.placeholder === "string")
        attrs.push(`placeholder="${escapeText(props.placeholder)}"`);
      const attrStr = attrs.length > 0 ? " " + attrs.join(" ") : "";
      const label =
        typeof props.label === "string" ? props.label : undefined;
      if (label) {
        return {
          jsx: `<div>\n  <label className="text-sm font-medium">${escapeText(label)}</label>\n  <Input${attrStr} />\n</div>`,
          imports: new Set(["Input"]),
        };
      }
      return {
        jsx: `<Input${attrStr} />`,
        imports: new Set(["Input"]),
      };
    }

    case "Link": {
      const href = typeof props.href === "string" ? props.href : "#";
      const text = typeof props.text === "string" ? escapeText(props.text) : undefined;
      const children = emitChildren(node.children ?? []);
      const body = text ?? children.jsx ?? href;
      return {
        jsx: `<Link href="${href}">${body}</Link>`,
        imports: new Set(["Link", ...Array.from(children.imports)]),
      };
    }

    case "Divider": {
      return {
        jsx: `<Separator />`,
        imports: new Set(["Separator"]),
      };
    }

    case "List": {
      const items = Array.isArray(props.items) ? props.items : [];
      const ordered = props.ordered === true;
      const tag = ordered ? "ol" : "ul";
      const listClass = ordered ? "list-decimal" : "list-disc";
      const lis = items
        .map((item) => `  <li>${escapeText(item)}</li>`)
        .join("\n");
      const body = lis ? `\n${lis}\n` : "";
      return {
        jsx: `<${tag} className="${listClass} pl-4">${body}</${tag}>`,
        imports: new Set(),
      };
    }

    case "Icon": {
      const iconName = typeof props.name === "string" ? props.name : "Star";
      const iconSize = typeof props.size === "number" ? props.size : 24;
      const iconColor = typeof props.color === "string" && props.color ? props.color : "";
      const sizeAttr = iconSize !== 24 ? ` size={${iconSize}}` : "";
      const colorAttr = iconColor ? ` color="${iconColor}"` : "";
      return {
        jsx: `<${iconName}${sizeAttr}${colorAttr} />`,
        imports: new Set([`lucide:${iconName}`]),
      };
    }

    // -- Component nodes ----------------------------------------------------

    case "Card": {
      const children = emitChildren(node.children ?? []);
      const padding = props.padding
        ? `p-${resolveSize(props.padding)}`
        : "p-4";
      const body = children.jsx
        ? `\n${indentLines(children.jsx, 6)}\n    `
        : "";
      return {
        jsx: `<Card>\n  <div className="${padding}">${body}</div>\n</Card>`,
        imports: new Set(["Card", ...Array.from(children.imports)]),
      };
    }

    case "Button": {
      const label = escapeText(props.label ?? "Button");
      const attrs: string[] = [];
      if (typeof props.intent === "string" && props.intent !== "primary") {
        attrs.push(`variant="${props.intent}"`);
      }
      if (typeof props.size === "string" && props.size !== "default") {
        attrs.push(`size="${props.size}"`);
      }
      const attrStr = attrs.length > 0 ? " " + attrs.join(" ") : "";
      return {
        jsx: `<Button${attrStr}>${label}</Button>`,
        imports: new Set(["Button"]),
      };
    }

    case "Form": {
      const formAttrs: string[] = [];
      if (typeof props.action === "string") formAttrs.push(`action="${escapeText(props.action)}"`);
      if (typeof props.method === "string") formAttrs.push(`method="${props.method}"`);
      const formAttrStr = formAttrs.length > 0 ? " " + formAttrs.join(" ") : "";
      const children = emitChildren(node.children ?? []);
      const body = children.jsx ? `\n${indentLines(children.jsx, 2)}\n` : "";
      return {
        jsx: `<form${formAttrStr} className="space-y-4">${body}</form>`,
        imports: children.imports,
      };
    }

    case "Modal": {
      const title = escapeText(props.title ?? "Dialog");
      const children = emitChildren(node.children ?? []);
      const body = children.jsx ? `\n${indentLines(children.jsx, 6)}\n    ` : "";
      return {
        jsx: `<dialog open className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
  <div className="bg-background border rounded-xl shadow-lg max-w-md w-full">
    <div className="flex items-center justify-between px-4 py-3 border-b">
      <span className="font-semibold">${title}</span>
    </div>
    <div className="p-4">${body}</div>
  </div>
</dialog>`,
        imports: children.imports,
      };
    }

    case "Tabs": {
      const tabs = Array.isArray(props.tabs) ? props.tabs.map(String) : ["Tab 1", "Tab 2"];
      const children = emitChildren(node.children ?? []);
      const tabButtons = tabs.map((tab, i) =>
        `    <button className="${i === 0 ? 'border-b-2 border-blue-500 text-blue-600 font-medium' : 'text-muted-foreground'} px-4 py-2 text-sm">${escapeText(tab)}</button>`
      ).join("\n");
      const body = children.jsx ? `\n${indentLines(children.jsx, 2)}\n` : "";
      return {
        jsx: `<div>
  <div className="flex border-b mb-3">
${tabButtons}
  </div>
  <div>${body}</div>
</div>`,
        imports: children.imports,
      };
    }

    case "Nav": {
      const orientation = props.orientation === "vertical" ? "vertical" : "horizontal";
      const items = Array.isArray(props.items) ? props.items : [];
      const flexDir = orientation === "vertical" ? "flex-col" : "flex-row";
      const borderClass = orientation === "horizontal" ? "border-b pb-2" : "border-r pr-2";
      const navItems = items.map((item) => {
        const str = String(item);
        const [label, href] = str.includes("|") ? str.split("|") : [str, "#"];
        return `  <Link href="${href}" className="px-3 py-1.5 text-sm rounded-md hover:bg-accent">${escapeText(label)}</Link>`;
      }).join("\n");
      const children = emitChildren(node.children ?? []);
      const childBody = children.jsx ? `\n${indentLines(children.jsx, 2)}\n` : "";
      return {
        jsx: `<nav className="flex ${flexDir} gap-1 ${borderClass}">
${navItems}${childBody}</nav>`,
        imports: new Set(["Link", ...Array.from(children.imports)]),
      };
    }

    case "DataTable": {
      const columns = Array.isArray(props.columns) ? props.columns : [];
      const rows = Array.isArray(props.rows) ? props.rows : [];
      const parsedCols = columns.map((c) => {
        const str = String(c);
        if (str.includes("|")) {
          const [key, label] = str.split("|");
          return { key, label };
        }
        return { key: str, label: str };
      });
      const parsedRows = rows.map((r) => {
        if (typeof r === "object" && r !== null) return r as Record<string, unknown>;
        try { return JSON.parse(String(r)) as Record<string, unknown>; } catch { return {} as Record<string, unknown>; }
      });

      const thCells = parsedCols.map(
        (col) => `        <th className="text-left px-4 py-2 font-medium">${escapeText(col.label)}</th>`
      ).join("\n");

      const rowJsx = parsedRows.map((row, i) => {
        const cells = parsedCols.map(
          (col) => `          <td className="px-4 py-2">${escapeText(String(row[col.key] ?? ""))}</td>`
        ).join("\n");
        return `        <tr key={${i}} className="border-b last:border-b-0">\n${cells}\n        </tr>`;
      }).join("\n");

      return {
        jsx: `<div className="border rounded-lg overflow-hidden">
  <table className="w-full text-sm">
    <thead>
      <tr className="bg-muted/50 border-b">
${thCells}
      </tr>
    </thead>
    <tbody>
${rowJsx}
    </tbody>
  </table>
</div>`,
        imports: new Set(),
      };
    }

    // -- Repo component (fallback) ------------------------------------------

    default: {
      return emitRepoComponent(node);
    }
  }
}

function emitRepoComponent(node: Node): EmitResult {
  const props = node.props ?? {};
  const children = emitChildren(node.children ?? []);

  const propEntries = Object.entries(props).map(([key, value]) => {
    if (typeof value === "string") return `${key}="${escapeText(value)}"`;
    return `${key}={${JSON.stringify(value)}}`;
  });
  const attrStr = propEntries.length > 0 ? " " + propEntries.join(" ") : "";

  if (children.jsx) {
    const body = `\n${indentLines(children.jsx, 2)}\n`;
    return {
      jsx: `<${node.type}${attrStr}>${body}</${node.type}>`,
      imports: new Set([node.type, ...Array.from(children.imports)]),
    };
  }

  return {
    jsx: `<${node.type}${attrStr} />`,
    imports: new Set([node.type, ...Array.from(children.imports)]),
  };
}

/** Wrap emitted JSX with interaction handlers and visibility conditionals. */
function emitNodeWithInteractions(node: Node): EmitResult {
  const result = emitNode(node);
  let { jsx } = result;
  const imports = new Set(result.imports);

  // Inject onClick/onChange into the outermost tag
  if (node.interactions) {
    const onClickStr = buildOnClick(node.interactions);
    const onChangeStr = buildOnChange(node.interactions);

    if (node.interactions.onClick?.action === "navigate") {
      imports.add("__useRouter");
    }

    // Inject handler attributes right after the first tag opening
    if (onClickStr || onChangeStr) {
      const handlers = `${onClickStr}${onChangeStr}`;
      // Find the first > or /> and inject before it
      const firstClose = jsx.match(/^(<[a-zA-Z][a-zA-Z0-9]*(?:\s[^>]*?)?)(\/?>)/);
      if (firstClose) {
        jsx = firstClose[1] + handlers + firstClose[2] + jsx.slice(firstClose[0].length);
      }
    }

    // Wrap with visibility conditional
    if (node.interactions.visibleWhen) {
      const { state, operator, value } = node.interactions.visibleWhen;
      let condition: string;
      switch (operator) {
        case "eq":
          condition = `${state} === ${JSON.stringify(value ?? "")}`;
          break;
        case "neq":
          condition = `${state} !== ${JSON.stringify(value ?? "")}`;
          break;
        case "truthy":
        default:
          condition = state;
          break;
      }
      jsx = `{${condition} && (\n${indentLines(jsx, 2)}\n)}`;
    }
  }

  return { jsx, imports };
}

function emitChildren(nodes: Node[]): EmitResult {
  const imports = new Set<string>();
  const parts = nodes.map((node) => {
    const result = emitNodeWithInteractions(node);
    mergeImports(imports, result.imports);
    return result.jsx;
  });
  return { jsx: parts.join("\n"), imports };
}

// ---------------------------------------------------------------------------
// Screen-level emission
// ---------------------------------------------------------------------------

/** Collect all unique fontFamily values from a node tree. */
function collectFontFamilies(node: Node): Set<string> {
  const fonts = new Set<string>();
  const ff = node.props?.fontFamily;
  if (typeof ff === "string" && ff) {
    fonts.add(ff);
  }
  if (node.children) {
    for (const child of node.children) {
      collectFontFamilies(child).forEach((f) => fonts.add(f));
    }
  }
  return fonts;
}

/** Build Google Fonts <link> tag for font families used in the screen. */
function buildFontLink(families: Set<string>, config: StudioConfig): string {
  // Only Google fonts need a link tag. Local fonts are loaded via @font-face.
  const googleFonts = config.fonts?.filter((f) => f.source === "google") ?? [];
  const googleFamilies = Array.from(families).filter((family) =>
    googleFonts.some((g) => g.family === family)
  );

  if (googleFamilies.length === 0) return "";

  const familyParams = googleFamilies
    .map((f) => `family=${encodeURIComponent(f)}:wght@300;400;500;600;700`)
    .join("&");
  return `<link rel="stylesheet" href="https://fonts.googleapis.com/css2?${familyParams}&display=swap" />\n`;
}

export function emitScreen(
  spec: ScreenSpec,
  config: StudioConfig
): EmitScreenResult {
  const componentName = componentNameFromRoute(spec.route);
  const pagePath = pagePathFromRoute(spec.route, config.appDir);
  const generatedPath = `${config.generatedDir}/${componentName}.generated.tsx`;

  // Emit the tree (root uses emitNodeWithInteractions in case root itself has interactions)
  const emitted = emitNodeWithInteractions(spec.tree);

  // Collect font families used in this screen
  const usedFonts = collectFontFamilies(spec.tree);
  const fontLinkTag = buildFontLink(usedFonts, config);

  // Collect interaction state variables
  const interactionStates = collectInteractionState(spec.tree);
  const apiSources = collectApiSources(spec.tree);

  const needsUseState = interactionStates.size > 0 || apiSources.length > 0;
  const needsUseEffect = apiSources.length > 0;
  const needsRouter = emitted.imports.has("__useRouter");
  emitted.imports.delete("__useRouter");

  // Build page file -- include font link if needed
  let pageHead = "";
  if (fontLinkTag) {
    pageHead = `import Head from "next/head";\n`;
  }
  const headBlock = fontLinkTag
    ? `\n      <Head>\n        ${fontLinkTag.trim()}\n      </Head>`
    : "";

  // "use client" directive needed if we have stateful interactions
  const useClientDirective = (needsUseState || needsRouter) ? '"use client";\n\n' : "";

  const pageContents = `${HEADER}${pageHead}import { ${componentName} } from "${config.importAlias}components/generated";

export default function Page() {
  return (
    <>${headBlock}
      <${componentName} />
    </>
  );
}
`;

  // Build component file
  const importLines = buildImportLines(emitted.imports, config);

  // React hooks imports
  const reactHooks: string[] = [];
  if (needsUseState) reactHooks.push("useState");
  if (needsUseEffect) reactHooks.push("useEffect");
  const reactImport = reactHooks.length > 0 ? `import { ${reactHooks.join(", ")} } from "react";\n` : "";
  const routerImport = needsRouter ? `import { useRouter } from "next/navigation";\n` : "";

  // State declarations
  const stateLines = Array.from(interactionStates).map(
    (s) => `  const [${s}, set${capitalize(s)}] = useState(false);`
  );

  // API data source state + useEffect
  for (const api of apiSources) {
    const varName = `data_${api.nodeId.replace(/[^a-zA-Z0-9]/g, "_")}`;
    stateLines.push(`  const [${varName}, set${capitalize(varName)}] = useState<unknown[]>([]);`);
    stateLines.push(`  useEffect(() => {`);
    stateLines.push(`    fetch("${api.url}").then(r => r.json()).then(d => set${capitalize(varName)}(Array.isArray(d) ? d : [])).catch(() => {});`);
    stateLines.push(`  }, []);`);
  }

  const routerLine = needsRouter ? "  const router = useRouter();\n" : "";
  const stateBlock = stateLines.length > 0 ? stateLines.join("\n") + "\n" : "";

  const body = emitted.jsx ? `\n${indentLines(emitted.jsx, 4)}\n` : "\n";
  const componentContents = `${HEADER}${useClientDirective}${reactImport}${routerImport}${importLines}export function ${componentName}() {
${routerLine}${stateBlock}  return (${body}  );
}
`;

  return {
    files: [
      { path: pagePath, contents: pageContents },
      { path: generatedPath, contents: componentContents },
    ],
    componentName,
  };
}

// ---------------------------------------------------------------------------
// Barrel index generation
// ---------------------------------------------------------------------------

export function emitBarrelIndex(
  componentNames: string[],
  config: StudioConfig
): EmittedFile {
  const exports = componentNames
    .sort()
    .map((name) => `export { ${name} } from "./${name}.generated";`)
    .join("\n");

  return {
    path: `${config.generatedDir}/index.ts`,
    contents: `${HEADER}${exports}\n`,
  };
}

// ---------------------------------------------------------------------------
// Emitter interface implementation
// ---------------------------------------------------------------------------

export const nextjsEmitter: Emitter = {
  name: "nextjs",
  emitScreen,
  emitBarrelIndex,
};
